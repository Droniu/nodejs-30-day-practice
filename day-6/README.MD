# âš™ï¸ Node.js Child Processes â€” Complete Guide

Node.js may be single-threaded, but itâ€™s not weak.
When your API needs to crunch numbers, generate PDFs, or run external commands without blocking the main thread â€” thatâ€™s where **child processes** step in. ğŸ§ 

## ğŸ§© Why Spawn a Child Process?

Child processes let your app:

- ğŸš€ Run **CPU-heavy** or **blocking** tasks outside the event loop
- ğŸ§µ Perform **parallel operations** safely
- âš™ï¸ Use **native executables** (Python, FFmpeg, wkhtmltopdf, etc.)
- ğŸ§° Keep your **main API responsive** â€” even under heavy load

Think of your API as the manager and each child process as a temp worker doing specialized jobs.

## ğŸ”§ The Core Players

| Method                            | Description                                 | Use Case                           |
| --------------------------------- | ------------------------------------------- | ---------------------------------- |
| `spawn(command, args, options)`   | Starts a new process with **streaming I/O** | Long-running tasks, streaming logs |
| `exec(command, callback)`         | Runs a command and buffers output           | Quick shell commands               |
| `fork(modulePath, args, options)` | Spawns another Node script with IPC         | Background workers, micro-tasks    |

## ğŸš€ Example: `spawn()` in Action

```js
import { spawn } from "child_process";

const child = spawn("ping", ["-c", "5", "google.com"]);

child.stdout.on("data", (data) => {
  console.log(`stdout: ${data}`);
});

child.stderr.on("data", (data) => {
  console.error(`stderr: ${data}`);
});

// exit gracefully with SIGTERM
process.on("SIGTERM", () => {
  child.kill("SIGTERM");
  process.exit(0);
});
```

### ğŸ§  Whatâ€™s Going On

1. **`spawn()`** runs the `ping` command as a new process.
2. The **stdout** and **stderr** streams are read in real time.
3. When the parent receives **SIGTERM**, it kills the child too, preventing zombie processes ğŸ§Ÿâ€â™‚ï¸.

## â˜ ï¸ Common System Signals

| Signal      | Meaning                          | Typical Source       |
| ----------- | -------------------------------- | -------------------- |
| `SIGINT`    | Interrupt (Ctrl + C)             | User                 |
| `SIGTERM`   | Graceful stop                    | Docker, PM2, systemd |
| `SIGKILL`   | Immediate kill (canâ€™t be caught) | OS forced shutdown   |
| `SIGHUP`    | Terminal hang-up                 | SSH disconnect       |
| `SIGUSR1/2` | Custom signals                   | App-specific hooks   |

Handling them prevents resource leaks and half-dead child processes.

## ğŸ§± Useful Spawn Options

```js
spawn("node", ["worker.js"], {
  stdio: "inherit", // stream logs directly
  cwd: "./scripts", // run from subdirectory
  env: { ...process.env, NODE_ENV: "production" },
});
```

## ğŸ§© Real-World Patterns in Web APIs & CRUD Apps

Letâ€™s connect this to what you actually do in backend dev â€” no bullshit, just patterns that show up in real production code ğŸ‘‡

### ğŸ§¾ 1. Generating Reports or PDFs (Offloading Heavy Work)

Instead of freezing your API while generating PDFs or Excel files:

```js
// api/reports.js
import { spawn } from "child_process";

export const generateReport = async (req, res) => {
  const child = spawn("node", ["scripts/generateReport.js", req.query.id]);

  let output = "";
  child.stdout.on("data", (chunk) => (output += chunk));
  child.on("close", (code) => {
    if (code !== 0) return res.status(500).send("Report failed");
    res.type("application/pdf").send(output);
  });
};
```

ğŸ§© **Why it matters:** keeps the request loop fast, lets the child crunch data or render charts independently.

### ğŸ–¼ï¸ 2. Image / Video Processing Pipelines

```js
const ffmpeg = spawn("ffmpeg", [
  "-i",
  "input.mp4",
  "-vf",
  "scale=1280:-1",
  "output.mp4",
]);

ffmpeg.stdout.on("data", (d) => console.log(`ffmpeg: ${d}`));
ffmpeg.stderr.on("data", (d) => console.error(`ffmpeg err: ${d}`));
```

Used for:

- Creating thumbnails
- Transcoding uploads
- Watermarking media

In a CRUD app, this could be triggered on a â€œnew uploadâ€ event.

### ğŸ“¬ 3. Background Email / Queue Workers

When your API endpoint should respond fast and let a background job handle side effects:

```js
// POST /users
const child = fork("./workers/sendWelcomeEmail.js");
child.send({ email: user.email });
```

```js
// workers/sendWelcomeEmail.js
process.on("message", async (data) => {
  await sendEmail(data.email);
  process.exit(0);
});
```

ğŸ’¡ Pattern often combined with queues like **BullMQ**, **SQS**, or **RabbitMQ**, but forked child workers work great for small apps.

### ğŸ’¾ 4. Database Migrations or Batch Scripts

In admin APIs, you may trigger schema migrations or cleanups as subprocesses:

```js
app.post("/admin/run-migration", (req, res) => {
  const child = spawn("npm", ["run", "migrate"], { stdio: "inherit" });
  res.json({ status: "Migration started" });
});
```

This avoids blocking your Node API while a migration runs for minutes.

### ğŸ“¡ 5. Chaining Processes Together (Piping)

Example: `ps aux | grep node`

```js
const ps = spawn("ps", ["aux"]);
const grep = spawn("grep", ["node"]);

ps.stdout.pipe(grep.stdin);
grep.stdout.on("data", (data) => console.log(`Processes:\n${data}`));
```

ğŸ§© Handy for log filtering, analytics, or chaining CLI tools.

## ğŸ’¬ Communication with Child Processes

When you need structured data back (not stdout parsing), use `fork()`:

```js
// parent.js
const child = fork("./childWorker.js");

child.on("message", (msg) => console.log("Result:", msg));
child.send({ task: "sum", a: 5, b: 8 });
```

```js
// childWorker.js
process.on("message", (msg) => {
  if (msg.task === "sum") process.send({ result: msg.a + msg.b });
});
```

Perfect for CPU-bound calculations in web APIs like price recalculations or AI inference jobs.

## ğŸ”¥ Common Questions

### âš™ï¸ Whatâ€™s the difference between `spawn` and `exec`?

- `spawn`: streams output â†’ better for long-running processes
- `exec`: buffers output â†’ better for short commands

### ğŸ§  What happens if the parent exits first?

The child keeps running â€” a **zombie** process.
Always clean up via signals or `child.kill()`.

### ğŸ’£ How to kill a child process manually?

```js
child.kill("SIGTERM"); // graceful
child.kill("SIGKILL"); // instant death
```

### ğŸ§© How to check if the process finished?

```js
child.on("close", (code) => console.log(`Exited with code ${code}`));
```

## ğŸ§° Bonus: Graceful Shutdown Pattern (for APIs & Workers)

```js
const children = [];

process.on("SIGTERM", () => {
  console.log("Shutting down gracefully...");
  children.forEach((c) => c.kill("SIGTERM"));
  process.exit(0);
});

function spawnTask() {
  const child = spawn("node", ["scripts/task.js"], { stdio: "inherit" });
  children.push(child);
}
```

Used in:

- ğŸ³ Docker containers
- ğŸ§‘â€ğŸ’» PM2-managed Node apps
- â˜ï¸ AWS ECS / Lambda (graceful pre-stop hooks)

## ğŸ§© TL;DR

- ğŸ§µ Use `spawn()` for long-running tasks (e.g., ffmpeg, ping, reports)
- ğŸ’¾ Use `exec()` for simple shell commands
- ğŸ§  Use `fork()` for Node-to-Node background workers
- âš°ï¸ Always handle `SIGTERM` to avoid zombies
- ğŸš€ Child processes make APIs scalable and responsive by offloading blocking work

Would you like me to add **Docker-friendly patterns** next (e.g., how to propagate `SIGTERM` correctly inside containers and handle `process.on('SIGINT')` for ECS/Compose environments)?
Thatâ€™s a super common real-world issue with child processes in APIs.
